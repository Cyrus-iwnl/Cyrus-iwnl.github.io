[{"content":"","date":"2025-04-22T17:20:00Z","image":"https://Cyrus-iwnl.github.io/p/golang-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-day2/go_hu_c3e7c2bbe2754d35.jpg","permalink":"https://Cyrus-iwnl.github.io/p/golang-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-day2/","title":"Golang 学习日记 Day2"},{"content":"包、变量与函数 包（Package） Go 程序由包组成。每个 Go 源文件都需要以 package 声明开头。常见的 main 包表示可独立运行的程序，其入口为 main() 函数。\n导入（Import） 通过 import 关键字导入其他包，例如：\n1 import \u0026#34;fmt\u0026#34; 导出名（Exported Name） 在 Go 中，以大写字母开头的标识符是可导出的（即公有），小写开头的则是私有的。\n函数（Function） 函数使用 func 关键字定义，例如：\n1 2 3 func add(a int, b int) int { return a + b } 多返回值 Go 支持一个函数返回多个值：\n1 2 3 func swap(x, y string) (string, string) { return y, x } 带名字的返回值 返回值可以具名：\n1 2 3 4 5 func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return } 变量 声明变量 使用 var 声明变量：\n1 var i int 初始化变量 可以同时声明并初始化：\n1 var j int = 1 短变量声明 函数内部可以使用更简洁的 := 方式：\n1 k := 3 基本类型 Go 提供诸如 int, float64, bool, string 等基本类型。\n零值 未显式初始化的变量会被赋予“零值”。\n类型转换与类型推断 Go 不支持隐式类型转换，必须显式转换：\n1 2 var i int = 42 var f float64 = float64(i) Go 具有类型推断能力：\n1 v := 42 // 推断为 int 类型 常量 使用 const 定义常量：\n1 2 const Pi = 3.14 控制结构 for 循环 Go 仅有一种循环结构：for。\n1 2 3 for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } 无限循环 1 2 3 for { // ... } for 是 Go 中的 while 可用 for 模拟 while：\n1 2 3 for condition { // ... } 条件语句 if 判断 1 2 3 if x \u0026lt; 0 { x = -x } if 与简短语句 1 2 3 if v := math.Pow(x, n); v \u0026lt; lim { return v } if-else 1 2 3 4 5 if x \u0026lt; y { return x } else { return y } switch 分支 1 2 3 4 5 6 7 8 switch i { case 0: fmt.Println(\u0026#34;Zero\u0026#34;) case 1: fmt.Println(\u0026#34;One\u0026#34;) default: fmt.Println(\u0026#34;Other\u0026#34;) } 求值顺序 Go 的 switch 自动在 case 匹配成功后退出，无需 break。\n无条件 switch 1 2 3 4 5 6 7 8 switch { case x \u0026gt; 0: fmt.Println(\u0026#34;Positive\u0026#34;) case x \u0026lt; 0: fmt.Println(\u0026#34;Negative\u0026#34;) default: fmt.Println(\u0026#34;Zero\u0026#34;) } defer 延迟调用 defer 会在函数返回前调用指定的语句，常用于资源释放。\n1 2 3 4 func main() { defer fmt.Println(\u0026#34;world\u0026#34;) fmt.Println(\u0026#34;hello\u0026#34;) } 调用顺序为后进先出（LIFO）\n指针与结构体 指针 1 2 var p *int p = \u0026amp;i 结构体 1 2 3 4 type Vertex struct { X int Y int } 结构体字段与指针 1 2 3 v := Vertex{1, 2} p := \u0026amp;v p.X = 1e9 结构体字面量 1 Vertex{X: 1, Y: 2} 数组与切片 数组 1 var a [2]string 切片 1 s := []int{1, 2, 3} 切片类数组的引用特性 切片是对底层数组的引用，多个切片可共享底层数据。\n切片默认行为 1 s[lo:hi] 长度与容量\n1 len(s), cap(s) nil 切片与 make 创建\n1 2 var s []int // nil s := make([]int, 5) 向切片添加元素\n1 s = append(s, 6) range 遍历\n1 2 3 for i, v := range s { fmt.Println(i, v) } Map 映射 定义与初始化 1 2 m := make(map[string]int) m[\u0026#34;Answer\u0026#34;] = 42 映射字面量 1 2 3 4 m := map[string]int{ \u0026#34;Alice\u0026#34;: 25, \u0026#34;Bob\u0026#34;: 30, } 修改、删除键值对 1 2 delete(m, \u0026#34;Bob\u0026#34;) value, ok := m[\u0026#34;Alice\u0026#34;] 函数进阶 函数值 1 2 3 hypot := func(x, y float64) float64 { return math.Sqrt(x*x + y*y) } 函数闭包 1 2 3 4 5 6 7 func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } ","date":"2025-04-22T16:43:16Z","image":"https://Cyrus-iwnl.github.io/p/golang-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-day1/go_hu_c3e7c2bbe2754d35.jpg","permalink":"https://Cyrus-iwnl.github.io/p/golang-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-day1/","title":"Golang 学习日记 Day1"},{"content":" 本文非本人撰写，全文来源于：https://zhuanlan.zhihu.com/p/338835258\n引言 CAP 理论，相信很多人都听过，它是指： 一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。\n为什么要理解 CAP 理论？我能说出很多理由来。如果是在职场上，也许最合适的理由是，当领导给出的任务不靠谱时，我们可以依据 CAP 去否决它。 比如，有这么一个任务，给你定了三大目标： 1. 既要提升系统的可用性 2. 又要保证数据的实时可见 3. 还有提升系统的容错能力 看到“既要、又要、还要”，是不是想到了阿里…… OK，如果你深刻理解了 CAP，你会发现完成这个任务是不可能的。但是，如果你不理解 CAP，然后又拍了胸脯保证完成任务，不好意思，职场是不需要眼泪和后悔的。 有点跑题了，书归正传。CAP 理论是分布式设计中最基础最重要的理论，不懂它，你可能连分析一套分布式系统的核心设计理念都做不到。 关于 CAP 为何你读了那么多文章都还是搞不明白呢？因为 CAP 理论来自学术界，而解读 CAP 理论的人尝试用工程师的方式去阐述它，这本身就有了问题。\nCAP 本身基于状态，基于瞬态，是一个描述性的理论，它并不解决工程问题。但是，很多工程师却总是尝试为 CAP 做过多解读。比如，非要说 CAP 理论只能适合某某场景，非要说 CAP 理论里的一致性是非常强的一致性，把其和事务的一致性混为一谈。\n由于 CAP 是学术理论，并不是工程理论，它会舍弃很多现实世界的现实问题。比如网络的时长，比如节点内部的处理速度不一致，比如节点间存储方式和速度的不一致。它说的一致性就是客户端是否能拿到最新数据，它说的可用性就是允许客户端拿不到最新数据。而这些东西被工程师们的过多脑补，导致了文章和文章说法不一样，解析不一样，阐述背景不一样。\n在今天这篇文章中，我们只解释和说明，不脑补，不过多从工程角度解读，只说本质，只指核心，希望能真正说清楚、讲明白 CAP 理论。望本文能达到这个目的。\n接下来你看到文字，我前前后后写了 10 天，已经是这篇文章的第三版了，前两版写了一半都被我推翻重写了，因为我自己看了都不满意。 一方面是对自己知识掌握程度不满意，本以为自己明白 CAP 了，直到写的时候，发现有些还是拿不准。 另一方面是不满意自己的写的太晦涩、太教科书，能把知识讲的通俗易懂，才是我希望的。 给大家看看文章上辈子的模样。\nCAP 的由来 要理解 CAP，首先我们要清楚，为何会有人提出 CAP？他提出 CAP 是为了解决什么问题？\n时间回到 1985 年，彼时，后来证明了 CAP 理论的 Lynch 教授此时给当时的 IT 界来了一记惊雷：\n她通过不可辩驳的证明告诉业界的工程师们，如果在一个不稳定（消息要么乱序要么丢了）的网络环境里（分布式异步模型），想始终保持数据一致是不可能的。\n这是个什么概念呢？就是她打破了那些既想提供超高质量服务，又想提供超高性能服务的技术人员的幻想。\n这本质是在告诉大家，在分布式系统里，需要妥协。\n但是，如何妥协？分布式系统里到底应该怎么权衡这种 trade-off？\n我们可以想象一下，在 CAP 定理提出之前，没有这些方向性的指引，在设计和实施分布式系统时该有多么混乱。一套分布式系统是由多个模块组成的，这些模块本身可能由不同的开发人员去完成。然而，对于这些人，在公共层面，竟然没有一个原则去指导他们该怎么完成这套功能。\n比如，我们在同步两个节点的数据时，如果发生了错误，到底我们应该怎么做呢？如果没有统一的标准和方向，那很可能在一套分布式系统中的不同模块，会出现不同的处理情况。\n假设一套系统，由 A、B 两个模块构成。\nA 模块的设计理念是：节点间出现了问题，它可能会选择不断的重试，一直等到节点通信恢复。\n而 B 的设计理念是：节点间出现了问题，它断开就是了，可能最多就记录下状态，等以后处理。\n可是，当 A、B 之间出现了通信怎么办？那会出现 A 往 B 发请求，出问题会不断重试。而 B 往 A 发请求，出问题则直接断开的情况。\n当然，在后面我们会说明，CAP 的理念在实际工程中，会允许这种不一致。可是，那种不一致是提前设计好和规划好的，是根据实际数据的重要性和业务需求做的妥协，而不是这种混乱的妥协。\n所以，IT 界的人们就一直在摸索，试图找到一些纲领去指导分布式系统的设计，这一找就找了 15 年。\n2000 年时，Eric Brewer 教授在 PODC 会议上提出了 CAP 理论，但是由于没有被证明过，所以，当时只能被称为 CAP 猜想。这个猜想引起了巨大的反响，因为 CAP 很符合人们对设计纲领的预期。\n在 2002 年后，经过 Seth Gilbert 和 Nancy Lynch 从理论上证明了 CAP 猜想后，CAP 理论正式成为了分布式系统理论的基石之一。\nCAP 到底是什么 CAP 定理表达了一个分布式系统里不可能同时满足以下的三个特性：\nC：数据一致性 什么是数据一致性？咋一看真的很让人糊涂，一致性是什么？是指数据能一起变化，是能让数据整齐划一。\n那么问题又来了，数据何时会变化？数据怎么才能被称为一起变化？我们现在来回答这些问题，当我们搞清楚了这些问题，那么对数据一致性就会有了清晰的理解。\n首先第一个问题，数据何时会一起变化？\n答案是：仅且仅当包含数据的服务，收到数据更新请求的时候，数据才会发生变化。而数据更新请求则仅包括数据的增、删、改这三种请求，而这三种请求又被统称为写请求。所以，数据只有在写请求的时候才会发生变化。\n那我们来回答第二个问题，数据要怎么样才能被称为一起变化了？即谁来判断数据是最终变化了？是服务器对写请求的返回结果吗？告诉写请求成功，数据就一定发生一致性变化了？\nNO，数据发生变化是否一致是需要经过读请求来做检验的。那么读请求判断的依据是什么呢？\n假设，我们的分布式存储系统有两个节点，每个节点都包含了一部分需要被变化的数据。如果经过一次写请求后，两个节点都发生了数据变化。然后，读请求把这些变化后的数据都读取到了，我们就把这次数据修改称为数据发生了一致性变化。\n但是，这还不是完整的一致性。因为系统不可能永久的正常运行下去。\n如果系统内部发生了问题从而导致系统的节点无法发生一致性变化会怎么样呢？当我们这样做的时候，就意味着想看到最新数据的读请求们，很可能会看到旧数据，或者说获取到不同版本的数据。此时，为了保证分布式系统对外的数据一致性，于是选择不返回任何数据。\n这里需要注意一下，CAP 定理是在说在某种状态下的选择，和实际工程的理论是有差别的。上面描述的一致性和 ACID 事务中的一致性是两回事。事务中的一致性包含了实际工程对状态的后续处理。但是 CAP 定理并不涉及到状态的后续处理，对于这些问题，后续出现了 BASE 理论等工程结论去处理，目前，只需要明白 CAP 定理主要描述的是状态。\nA：可用性 奥维德曾经说过：“行动被人们遗忘，结果却将永存”。\n这句话说明了结果的重要性，而可用性在 CAP 里就是对结果的要求。它要求系统内的节点们接收到了无论是写请求还是读请求，都要能处理并给回响应结果。只是它有两点必须满足的条件：\n条件 1：返回结果必须在合理的时间以内，这个合理的时间是根据业务来定的。业务说必须 100 毫秒内返回，合理的时间就是 100 毫秒，需要 1 秒内返回，那就是 1 秒，如果业务定的 100 毫秒，结果却在 1 秒才返回，那么这个系统就不满足可用性。\n条件 2：需要系统内能正常接收请求的所有节点都返回结果。这包含了两重含义：\n如果节点不能正常接收请求了，比如宕机了，系统崩溃了，而其他节点依然能正常接收请求，那么，我们说系统依然是可用的，也就是说，部分宕机没事儿，不影响可用性指标。 如果节点能正常接收请求，但是发现节点内部数据有问题，那么也必须返回结果，哪怕返回的结果是有问题的。比如，系统有两个节点，其中有一个节点数据是三天前的，另一个节点是两分钟前的，如果，一个读请求跑到了包含了三天前数据的那个节点上，抱歉，这个节点不能拒绝，必须返回这个三天前的数据，即使它可能不太合理。\nP：分区容忍性 分布式的存储系统会有很多的节点，这些节点都是通过网络进行通信。而网络是不可靠的，当节点和节点之间的通信出现了问题，此时，就称当前的分布式存储系统出现了分区。但是，值得一提的是，分区并不一定是由网络故障引起的，也可能是因为机器故障。\n比如，我们的分布式存储系统有 A、B 两个节点。那么，当 A、B 之间由于可能路由器、交换机等底层网络设备出现了故障，A 和 B 通信出现了问题，但是 A、B 依然都在运行，都在对外提供服务。这时候，就说 A 和 B 发生了分区。\n还有一种情况也会发生分区，当 A 出现了宕机，A 和 B 节点之间通信也是出现了问题，那么我们也称 A 和 B 发生了分区。\n综上，我们可以知道，只要在分布式系统中，节点通信出现了问题，那么就出现了分区。\n那么，分区容忍性是指什么？ 它是说，如果出现了分区问题，我们的分布式存储系统还需要继续运行。不能因为出现了分区问题，整个分布式节点全部就熄火了，罢工了，不做事情了。\nCAP 怎么选择 我们上面已经知道了，在设计分布式系统时，架构师们在 C、A、P 这三种特性里，只能选择两种。\n但是，这道 CAP 的选择题，就像别人在问你“小明的父亲有三个孩子，老大叫大朗，老二叫二郎，请问老三叫什么”一样。在以分布式存系统为限定条件的 CAP 世界里，P 是早已经确定的答案，P 是必须的。\n因为，在分布式系统内，P 是必然的发生的，不选 P，一旦发生分区错误，整个分布式系统就完全无法使用了，这是不符合实际需要的。所以，对于分布式系统，我们只能能考虑当发生分区错误时，如何选择一致性和可用性。\n而根据一致性和可用性的选择不同，开源的分布式系统往往又被分为 CP 系统和 AP 系统。\n当一套系统在发生分区故障后，客户端的任何请求都被卡死或者超时，但是，系统的每个节点总是会返回一致的数据，则这套系统就是 CP 系统，经典的比如 Zookeeper。\n如果一套系统发生分区故障后，客户端依然可以访问系统，但是获取的数据有的是新的数据，有的还是老数据，那么这套系统就是 AP 系统，经典的比如 Eureka。\n说了这么多，其实 CAP 定理本质很简单，它就是一种分布式系统设计的不同理念概括，包括它说的一致性，可用性和分区容错性。这就类似一个大学的校训，是极度概念化的东西。\n所以，大白话来形容下 CAP 吧，CAP 就是告诉程序员们当分布式系统出现内部问题了，你要做两种选择：\n要么迁就外部服务，像外包公司。 要么让外部服务迁就你，像银行。 迁就外部服务就是我们不能因为我们自己的问题让外部服务的业务运行受到影响，所以要优先可用性。而让外部服务迁就我们，就要优先一致性。\n对 CAP 的常见误解 误解一：分布式系统因为 CAP 定理放弃了 C 或者 A 中的其中一个 很多人在没有对 CAP 做深入了解的情况下，听到很多人说分布式系统必须在 CAP 三个特性里选择两个，就觉得一套分布式系统肯定要么只有可用性要么只有一致性，不存在完整的可用性和一致性功能。\n这种理解是大有问题的。因为，P 这种问题发生的概率非常低，所以：\n当没有出现分区问题的时候，系统就应该有完美的数据一致性和可用性。\n你什么时候见过一个系统，当内部没有问题的时候，会经常让外部请求卡一下的？要么就冷不丁的提供陈旧的老数据？那还能叫系统吗？\n误解二：C 和 A 之间的选择是针对整个分布式系统的，只能整体考虑 C 和 A 之间的选择 这个理解也是不对的。当分区发生的时候，其实对一致性和可用性的抉择是局部性的，而不是针对整个系统的。\n可能是在一些子系统做一些抉择，甚至很可能只需要对某个事件或者数据，做一致性和可用性的抉择而已。\n比如，当我们做一套支付系统的时候，会员的财务相关像账户余额，账务流水是必须强一致性的。这时候，你就要考虑选 C。但是，会员的名字，会员的支付设置就不必考虑强一致性，可以选择可用性 A。\n一套分布式系统的运行，就像人生一样，就是一次又一次的选择。在不同阶段，不同的时刻有不同的事件发生的时候，又怎么可能会有完全一样的选择呢？\n误解三：CAP 的三个特性只有是和否两种极端选择，而不是一个范围 这种二元性的理解更是极其误导人。\nCAP 理论的三种特性不是 Boolean 类型的，不是一致和不一致，可用和不可用，分区和没分区的这类二选一的选项。而是这三种特性都是范围类型。\n拿可用性来说，就像我从银行取钱。当我目的是派发压岁钱的时候，我很可能就想全要新票子，但是，新票子很可能就还得多一个步骤，就是需要拿旧票子去换一些新票，此时，我可以多等会儿，能拿到新票子就好。而当我的目的就是做生活花销的时候，票子是新是旧，我根本不那么关心，快点拿到钱就行。这就是可用性的范围需求之一，对时延性的要求。\n再比如，分区容错则由于探测机制的问题，可能还得各节点搞投票去协商分区是否存在，当某一台机器出现了问题，可能不影响业务的话，就会被机器投票认为分区不存在。然后一直等到多数机器出现了问题，才会投票确认出现了分区问题。这就好像新冠疫情，还会分低、中、高风险区呢，不是一出现通信故障就都被逻辑认定为分区问题。\nCAP 理论的一些疑问 疑问一：在遵从 CAP 定理的系统中是否适合任意的写请求 首先，在 CAP 定理中，关于一致性会有多种说法，但是总的来说，都是在描述数据最新版本的可见性。而这些可见性往往代表的是读请求返回的数据的可见性。\n那么问题来了，当我们要求读数据的可见性的时候，对写数据有什么要求吗？\n比如，我们系统有三个节点，一个客户端给这个系统发了一个写请求，要求系统写入一个值为 20 的数据。那么，如果要满足 CAP 定理中的一致性，就需要在写完 20 这个数据之后，当其他客户端请求读取这个值为 20 的数据之后，无论请求被转发到系统中任何节点都能返回这个值。\n这就要求写入这个值为 20 的写请求必须成功写到三个节点上，此时，系统就满足了写一致性的。所以，我们可以说对于读一致性的要求是同时约束了写一致性的。\n其次，在 CAP 定理中，可用性本身要求对读、写请求都要处理。如果我们以可用性作为标准的时候，在发生分区错误时，由于我们对读请求并没有强行要求返回完全准确的数据，所以，可能在本次读请求之前的最近一次写请求可能是部分失败的。\n同样的例子，我们的分布式系统由三个节点组成，最近一次写请求想把值为 20 的数据写到三个节点上。但是，由于发生了分区问题，有一个节点通信故障，写请求写不过去，因此只有两个节点包含了值为 20 的数据。\n此时，写请求会返回给客户端一个结果，可能会告诉客户端写入成功了，也可能告诉客户端写入部分成功。\n这时候，当后续的读请求恰巧被发送到有通信故障的那个节点，系统可能只能返回一个空的结果。但是，由于系统处理和返回了读写请求，所以，系统是满足了 CAP 中的可用性的。\n疑问二：数据分片和数据副本的分布式系统是否都遵守 CAP 定理 我们知道，在一套大规模的分布式系统里，一定是既需要把海量数据做切分，存储到不同的机器上，也需要对这些存储了数据的机器做副本备份的。\n那么，如果，一个分布式系统里只有数据分片存储或者只有数据副本存储，他们都会遵守 CAP 定理吗？\n答案是当数据分片时，也是要遵守 CAP 定理，但是，是种非常特殊的遵守。\n当在一套分布式系统只有分片存储的时候，CAP 理论会表现成什么样？\n比如，我们有个分布式系统，由三个节点 a、b、c 组成。其中节点 a 存放了 A 表的数据，b 存放了 B 表的数据，c 存放了 C 表的数据。\n如果有一个业务，它的意图是想往 A 表插入一条新数据，在 B 表删除一条已有数据，在 C 表更新一条老数据，这个分布式系统该怎么处理这种业务？\n技术上我们对这种一个意图想做多件事的情况往往会包装成一个事务。当我们包装成一个事务以后，我们可能会通过先在 a 节点执行，然后去 b 节点执行，最后去 c 节点执行，等到都成功了，才会返回成功。\n但是，发生了分区以后怎么办？当在 a、b 节点都成功了，到 c 发现发生了通信故障？\n此时，根据 CAP 定理，你有两个选择，要么就直接返回一个部分成功的结果给客户端，要么直接卡死等客户端超时或者返回失败给客户端。当返回部分成功的时候，这就是选择了可用性（A），当卡死或者返回失败给客户端的时候，就是选择了一致性（C）。\n可是，我们将请求包装成了事务，而事务是要求要么都成功，要么都失败……为了遵守这种要求，对于分布式只有分片的情况，迫于客观条件，只能选择C。所以分片的分布式系统，往往都是 CP 的系统。\n可选择，但是无法选择是分布式系统只有分片数据存储的情况时，遵守 CAP 定理的特殊表现。\n而当分布式系统是多个节点，每个节点存储了完整的一套数据，别的节点只是完整数据的备份的时候，即使事务只在一台机器上成功，当发生分区故障的时候，我们也是可以有充分的余地选择是单机事务的回退 or 就此认为写成功的。\n单机事务的回退，就可以对外表现为选择了一致性。\n就此认为写成功，则可以认为选择了可用性。\n疑问三：为何有时候区分一个系统是 AP 还是 CP 是如此之难 因为，就像我们前面讲过的，由于 AP 或者 CP 的选择，可能仅局限为整套系统的局部，甚至某些特殊的数据上，而我们又是用这种局部的特性去描述了整套系统，所以就导致了区分的困难。而这本身其实也日渐成为了 CAP 的一个大问题，从而被人诟病。\nCAP 的不足 CAP 定理本身是没有考虑网络延迟的问题的，它认为一致性是立即生效的，但是，要保持一致性，是需要时间成本的，这就导致往往分布式系统多选择 AP 方式。\n由于时代的演变，CAP 定理在针对所有分布式系统的时候，出现了一些力不从心的情况，导致很多时候它自己会把以前很严谨的数学定义改成了比较松弛的业务定义，类似于我们看到，CAP 定理把一致性、可用性、分区容错都变成了一个范围属性，而这和 CAP 定理本身这种数学定理般的称呼是有冲突的，出现了不符合数学严谨定义的问题。\n在实践中以及后来 CAP 定理的提出者也承认，一致性和可用性并不仅仅是二选一的问题，只是一些重要性的区别，当强调一致性的时候，并不表示可用性是完全不可用的状态。比如，Zookeeper 只是在 master 出现问题的时候，才可能出现几十秒的不可用状态，而别的时候，都会以各种方式保证系统的可用性。而强调可用性的时候，也往往会采用一些技术手段，去保证数据最终是一致的。CAP 定理并没有给出这些情况的具体描述。\nCAP 理论从工程角度来看只是一种状态的描述，它告诉大家当有错的时候，分布式系统可能处在什么状态。但是，状态是可能变化的。状态间如何转换，如何修补，如何恢复是没有提供方向的。\n引申出来的 BASE 正因为 CAP 以上的种种不足，epay 的架构师 Dan Pritchett 根据他自身在大规模分布式系统的实践经验，总结出了 BASE 理论。BASE 理论是对 CAP 理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。\nBASE 理论是实践工程的理论，它弥补了CAP 理论过于抽象的问题，也同时解决了 AP 系统的总体工程实践思想，是分布式系统的核心理论之一，我们将在下一篇文章里，详细的讲解此套理论。\n大厂面试题 在文章最后，来几道大厂关于 CAP 的面试真题，检验一下你的学习效果，hiahiahia\n什么是 CAP 理论？ CAP 中的 P 是什么意思？ 为什么说分布式系统，只能在 C、A 中二选一？ 结合实际应用，CP、AP 该怎么选择？ ","date":"2025-04-20T12:50:37Z","image":"https://Cyrus-iwnl.github.io/p/cap-%E7%90%86%E8%AE%BA/cap_hu_32f977376ac38b8b.png","permalink":"https://Cyrus-iwnl.github.io/p/cap-%E7%90%86%E8%AE%BA/","title":"CAP 理论"},{"content":"k-D Tree (KDT, k-Dimension Tree) 是一种可以高效处理 k 维空间信息的数据结构。在结点数 n 远大于 $2^k$ 时，应用 k-D Tree 的时间效率很好。在算法竞赛的题目中，一般有 k=2。在本页面分析时间复杂度时，将认为 k 是常数。\n建树 k-D Tree 具有二叉搜索树的形态，二叉搜索树上的每个结点都对应 k 维空间内的一个点。其每个子树中的点都在一个 k 维的超长方体内，这个超长方体内的所有点也都在这个子树中。\n假设我们已经知道了 k 维空间内的 n 个不同的点的坐标，要将其构建成一棵 k-D Tree，步骤如下：\n若当前超长方体中只有一个点，返回这个点。 选择一个维度，将当前超长方体按照这个维度分成两个超长方体。 选择切割点：在选择的维度上选择一个点，这一维度上的值小于这个点的归入一个超长方体（左子树），其余的归入另一个超长方体（右子树）。 将选择的点作为这棵子树的根节点，递归对分出的两个超长方体构建左右子树，维护子树的信息。 为了方便理解，我们举一个 k=2 时的例子。\n其构建出 k-D Tree 的形态可能是这样的：\n其中树上每个结点上的坐标是选择的分割点的坐标，非叶子结点旁的 x 或 y 是选择的切割维度。\n这样的复杂度无法保证。对于 2,3 两步，我们提出两个优化：\n轮流选择 k 个维度，以保证在任意连续 k 层里每个维度都被切割到。 每次在维度上选择切割点时选择该维度上的 中位数，这样可以保证每次分成的左右子树大小尽量相等。 可以发现，使用优化 2 后，构建出的 k-D Tree 的树高最多为 $\\log n+O(1)$。\n现在，构建 k-D Tree 时间复杂度的瓶颈在于快速选出一个维度上的中位数，并将在该维度上的值小于该中位数的置于中位数的左边，其余置于右边。如果每次都使用 sort 函数对该维度进行排序，时间复杂度是 $O(n\\log^2 n)$ 的。事实上，单次找出 n 个元素中的中位数并将中位数置于排序后正确的位置的复杂度可以达到 $O(n)$。\n我们来回顾一下快速排序的思想。每次我们选出一个数，将小于该数的置于该数的左边，大于该数的置于该数的右边，保证该数在排好序后正确的位置上，然后递归排序左侧和右侧的值。这样的期望复杂度是 $O(n\\log n)$ 的。但是由于 k-D Tree 只要求要中位数在排序后正确的位置上，所以我们只需要递归排序包含中位数的 一侧。可以证明，这样的期望复杂度是 O(n) 的。在 algorithm 库中，有一个实现相同功能的函数 nth_element()，要找到 s[l] 和 s[r] 之间的值按照排序规则 cmp 排序后在 s[mid] 位置上的值，并保证 s[mid] 左边的值小于 s[mid]，右边的值大于 s[mid]，只需写 nth_element(s+l,s+mid,s+r+1,cmp)。\n借助这种思想，构建 k-D Tree 时间复杂度是 $O(n\\log n)$ 的。\n高维空间上的操作 查询 在查询高维矩形区域内的所有点的一些信息时，记录每个结点子树内每一维度上的坐标的最大值和最小值。如果当前子树对应的矩形与所求矩形没有交点，则不继续搜索其子树；如果当前子树对应的矩形完全包含在所求矩形内，返回当前子树内所有点的权值和；否则，判断当前点是否在所求矩形内，更新答案并递归在左右子树中查找答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int query(int p) { if (p == 0) return 0; boolean flag = false; for (int k = 0; k \u0026lt; 2; k++) { if (!(l.x[k] \u0026lt;= t[p].L[k] \u0026amp;\u0026amp; t[p].R[k] \u0026lt;= h.x[k])) { flag = true; } } if (!flag) return t[p].sum; for (int k = 0; k \u0026lt; 2; k++) { if (t[p].R[k] \u0026lt; l.x[k] || h.x[k] \u0026lt; t[p].L[k]) { return 0; } } int ans = 0; flag = false; for (int k = 0; k \u0026lt; 2; k++) { if (!(l.x[k] \u0026lt;= t[p].x[k] \u0026amp;\u0026amp; t[p].x[k] \u0026lt;= h.x[k])) { flag = true; } } if (!flag) ans = t[p].v; ans += query(t[p].l) + query(t[p].r); return ans; } 插入/删除 如果维护的这个 k 维点集是可变的，即可能会插入或删除一些点，此时 k-D Tree 的平衡性无法保证。由于 k-D Tree 的构造，不能支持旋转，类似与 FHQ Treap 的随机优先级也不能保证其复杂度。对此，有两种比较常见的维护方法。\n很多人会使用替罪羊树结构来维护。但是注意到在刚才的复杂度分析中，要求儿子的子树大小严格减半，即树高必须为严格的 $\\log n+O(1)$，而替罪羊树只满足树高 $O(\\log n)$，故查询复杂度无法保证。\n根号重构 插入的时候，先存下来要插入的点，每 B 次插入进行一次重构。\n删除打个标记即可。如果要求较为严格，可以维护树内有多少个被删除了，达到 B 则重构。\n修改复杂度均摊 $O(n\\log n/B)$，查询 $O(B+n^{1-\\frac1k})$，若二者数量同阶则 $B=O(\\sqrt{n\\log n})$ 最优（修改 $O(\\sqrt{n\\log n})$，查询 $O(\\sqrt{n\\log n}+n^{1-\\frac1k})$）。\n二进制分组 考虑维护若干棵 2 的自然数次幂的 k-D Tree，满足这些树的大小之和为 n。\n插入的时候，新增一棵大小为 1 的 k-D Tree，然后不断将相同大小的树合并（直接拍扁重构）。实现的时候可以只重构一次。\n容易发现需要合并的树的大小一定从 $2^0$ 开始且指数连续。复杂度类似二进制加法，是均摊 $O(n\\log^2 n)$ 的，因为重构本身带 $\\log$。\n查询的时候，直接分别在每棵树上查询，复杂度为 $O\\left(\\sum_{i\\geq0} (\\frac n{2^i})^{1-\\frac1k}\\right)=O(n^{1-\\frac1k})$。\n","date":"2025-04-12T12:09:42Z","image":"https://Cyrus-iwnl.github.io/p/k-d-tree/trees_hu_1edc70561686f638.jpg","permalink":"https://Cyrus-iwnl.github.io/p/k-d-tree/","title":"K-D Tree"},{"content":"动态规划（DP） 最长公共子序列 dp[i][j] : text1[0:i] 和 text2[0:j] 的公共子序列的最大长度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int m = text1.length(), n = text2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { char c1 = text1.charAt(i - 1); for (int j = 1; j \u0026lt;= n; j++) { char c2 = text2.charAt(j - 1); if (c1 == c2) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } 最长递增子序列 dp[i] ：以第 i 个数字结尾的最长递增子序列的长度，注意 nums[i] 必须被选取\n1 2 3 4 5 6 7 8 9 10 11 int[] dp = new int[n]; Arrays.fill(dp, 1); int ans = -1; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { if (nums[j] \u0026lt; nums[i]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } ans = Math.max(ans, dp[i]); } 背包问题 dp[j] : 到目前元素 i 为止，背包剩余容量为 j 时的最大价值。\n0-1背包 求最大价值\n1 2 3 4 5 6 int[] dp = new int[capacity + 1]; for (int w: weights) { for (int j = capacity; j \u0026gt;= w; j--) { dp[j] = Math.max(dp[j], dp[j - w] + v); } } 求方案数\n1 2 3 4 5 6 7 int[] dp = new int[capacity + 1]; dp[0] = 1; for (int w: weights) { for (int j = capacity; j \u0026gt;= w; j--) { dp[j] += dp[j - w]; } } 求最大长度\n1 2 3 4 5 6 7 8 int[] dp = new int[capacity + 1]; Arrays.fill(dp, Integer.MIN_VALUE); dp[0] = 0; for (int w: weights) { for (int j = capacity; j \u0026gt;= w; j--) { dp[j] = Math.max(dp[j], dp[j - w] + 1); } } 求最小长度\n1 2 3 4 5 6 7 8 int[] dp = new int[capacity + 1]; Arrays.fill(dp, Integer.MAX_VALUE / 2); dp[0] = 0; for (int w: weights) { for (int j = capacity; j \u0026gt;= w; j--) { dp[j] = Math.min(dp[j], dp[j - w] + 1); } } 完全背包 求最大价值\n1 2 3 4 5 6 int[] dp = new int[capacity + 1]; for (int w: weights) { for (int j = w; j \u0026lt;= capacity; j++) { dp[j] = Math.max(dp[j], dp[j - w] + v); } } 状态机 dp[i][j] 表示第 i 天结束之后，当前状态为 j 的累计最大收益。\n1 2 3 4 5 6 7 int[][] dp = new int[steps][stateCount]; initialize(dp[0]); // 设定初始状态 for (int t = 1; t \u0026lt; steps; t++) { // 遍历时间 for (int s = 0; s \u0026lt; stateCount; s++) { // 遍历状态 dp[t][s] = transition(dp, t, s); // 计算状态转移 } } 二分查找 搜索确定值，闭区间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public int bsearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } } return -1; } 搜索左边界，左闭右开 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public int bsearch(int[] nums, int target) { int left = 0; int right = nums.length; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else { right = mid; } } return left; // \u0026gt;=target 的最小值； } 搜索右边界，左闭右开 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public int bsearch(int[] nums, int target) { int left = 0; int right = nums.length; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026gt; target) { right = mid; } else { left = mid + 1; } } return left - 1; // \u0026lt;=target 的最大值 } 第 k 小：求最小的 x，满足 $\\le x$ 的数至少有 k 个。 第 k 大：求最大的 x，满足 $\\ge x$ 的数至少有 k 个。 回溯 选择 → 回溯 → 撤销选择\n元素无重，不可复选 组合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); LinkedList\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { backtrack(1, n, k); return res; } void backtrack(int start, int n, int k) { if (k == track.size()) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } for (int i = start; i \u0026lt;= n; i++) { track.addLast(i); backtrack(i + 1, n, k); track.removeLast(); } } } 排列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); LinkedList\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); boolean[] used; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { used = new boolean[nums.length]; backtrack(nums); return res; } void backtrack(int[] nums) { if (track.size() == nums.length) { res.add(new LinkedList(track)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) continue; used[i] = true; track.addLast(nums[i]); backtrack(nums); track.removeLast(); used[i] = false; } } } 元素可重，不可复选 组合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); LinkedList\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); int trackSum = 0; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int[] nums, int target) { Arrays.sort(nums); backtrack(nums, 0, target); return res; } void backtrack(int[] nums, int start, int target) { if (trackSum == target) { res.add(new LinkedList\u0026lt;\u0026gt;(track)); return; } if (trackSum \u0026gt; target) { return; } for (int i = start; i \u0026lt; nums.length; i++) { if (i \u0026gt; start \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } track.add(nums[i]); trackSum += nums[i]; backtrack(nums, i + 1, target); track.removeLast(); trackSum -= nums[i]; } } } 排列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); LinkedList\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); boolean[] used; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { Arrays.sort(nums); used = new boolean[nums.length]; backtrack(nums); return res; } void backtrack(int[] nums) { if (track.size() == nums.length) { res.add(new LinkedList(track)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) { continue; } if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !used[i - 1]) { continue; } track.add(nums[i]); used[i] = true; backtrack(nums); track.removeLast(); used[i] = false; } } } 元素无重，可复选 组合：将backtrack(nums, i + 1)改为 backtrack(nums, i) 排列：直接删去boolean[] used数组和判断过程。 前缀和、差分、线段树 数组元素不变，求区间和 → 前缀和 数组区间变化，求单点值 → 差分 数组区间变化，求区间和 → 线段树 前缀和 一维前缀和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class NumArray { private int[] preSum; public NumArray(int[] nums) { preSum = new int[nums.length + 1]; for (int i = 1; i \u0026lt; preSum.length; i++) { preSum[i] = preSum[i - 1] + nums[i - 1]; } } public int sumRange(int left, int right) { return preSum[right + 1] - preSum[left]; } } 二维前缀和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class NumMatrix { private int[][] preSum; public NumMatrix(int[][] matrix) { int m = matrix.length, n = matrix[0].length; if (m == 0 || n == 0) return; preSum = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1]; } } } public int sumRegion(int x1, int y1, int x2, int y2) { return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1]; } } 差分数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Difference { private int[] diff; public Difference(int[] nums) { diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { diff[i] = nums[i] - nums[i - 1]; } } public void increment(int i, int j, int val) { diff[i] += val; if (j + 1 \u0026lt; diff.length) { diff[j + 1] -= val; } } public int[] result() { int[] res = new int[diff.length]; res[0] = diff[0]; for (int i = 1; i \u0026lt; diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } 滑动窗口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void slidingWindow(String s) { // 用合适的数据结构记录窗口中的数据，根据具体场景变通 // 比如说，我想记录窗口中元素出现的次数，就用 map // 如果我想记录窗口中的元素和，就可以只用一个 int Object window = ... int left = 0, right = 0; while (right \u0026lt; s.length()) { char c = s[right++]; window.add(c) ... // 进行窗口内数据的一系列更新 // printf(\u0026#34;window: [%d, %d)\\n\u0026#34;, left, right); while (left \u0026lt; right \u0026amp;\u0026amp; window needs shrink) { char d = s[left++]; window.remove(d) ... // 进行窗口内数据的一系列更新 } } } 求子数组个数 越长越合法\n1 2 3 4 5 6 7 8 9 10 int ans = 0; int left = 0, right = 0, cnt = 0; while(right \u0026lt; nums.length) { if(nums[right++] == target) cnt++; while(left \u0026lt; right \u0026amp;\u0026amp; cnt \u0026gt;= k) { if(nums[left++] == target) cnt--; } ans += left; } return ans; 越短越合法\n1 2 3 ... ans += right - left; ... 恰好型滑动窗口：\n例如，要计算有多少个元素和恰好等于 k 的子数组，可以把问题变成：\n计算有多少个元素和 $\\ge k$ 的子数组。 计算有多少个元素和 \u0026gt; k，也就是 $\\ge k + 1$ 的子数组。 答案就是元素和 $\\ge k$的子数组个数，减去元素和$\\ge k+1$的子数组个数。这里把 \u0026gt; 转换成 $\\ge$，从而可以把滑窗逻辑封装成一个函数 f()，然后用 f(k) - f(k + 1)计算，无需编写两份滑窗代码。 单调栈 求下一个更大元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public int[] nextLargerElement(int[] nums) { int n = nums.length; int[] res = new int[n]; Arrays.fill(res, -1); Deque\u0026lt;Integer\u0026gt; s = new ArrayDeque\u0026lt;\u0026gt;(); // 这里放元素索引，而不是元素 for (int i = 0; i \u0026lt; n; i++) { while (!s.isEmpty() \u0026amp;\u0026amp; nums[s.peek()] \u0026lt; nums[i]) { int prev = s.pop(); res[prev] = i; } s.push(i); } return res; } 二叉树 普通二叉树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void dfs(TreeNode node) { if (node == null) { return; // 递归的终止条件 } // 前序： doSomething(); // 递归调用左子树 dfs(node.left); // 递归调用右子树 dfs(node.right); // 后序 doSomething(); } 二叉搜索树 1 2 3 4 5 6 7 8 void BST(TreeNode root, int target) { if (root.val == target) // 找到目标，做点什么 if (root.val \u0026lt; target) BST(root.right, target); if (root.val \u0026gt; target) BST(root.left, target); } 排序 快排 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int[] sortArray(int[] nums) { quicksort(nums, 0, nums.length - 1); return nums; } public void quicksort(int[] nums, int l, int r) { if (l \u0026gt;= r) return; int pivot = partition(nums, l, r); quicksort(nums, l, pivot); quicksort(nums, pivot + 1, r); } int partition(int[] nums, int l, int r) { int pivot = nums[l+(r-l)/2]; int i = l - 1, j = r + 1; while (i \u0026lt; j) { do i++; while (nums[i] \u0026lt; pivot); do j--; while (nums[j] \u0026gt; pivot); if (i \u0026lt; j) swap(nums, i, j); } return j; } void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } ","date":"2025-04-01T16:24:26Z","permalink":"https://Cyrus-iwnl.github.io/p/leetcode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","title":"leetcode 刷题笔记"}]